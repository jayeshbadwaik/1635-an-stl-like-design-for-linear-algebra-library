\documentclass[oneside,11pt,a4paper]{jbarticle}

\addbibresource{library.bib}

\subject{}
\subtitle{}
\title{D1635R0 : An STL-like Design for Linear Algebra Library}
\author{Jayesh Badwaik}

\begin{document}
\maketitle[\value{page}]
\begin{abstract}
  A linear algebra library is currently being considered for standardization in
  the C++ standard library through \cite{GuyDavidson2019}. Among other things,
  the above paper puts forth the objective of providing facilities and
  techniques for customization that enable users to optimize performance for
  their specific needs in a manner that only requires them to implement a
  minimal set of types and functions to integrate it with the rest of the linear
  algebra libraries.

  In this paper, we claim that a well-designed set of requirements imposed on
  the types and the functions allow us to write a linear algebra library which
  fulfills the above two objectives.  We also claim that the design allows one
  to carry out operation between types of libraries designed as above without
  having to perform generate additional temporaries for the purpose of
  compatibility of the two libraries. As the name suggests, the design is
  motivated by the design of the Standard Template Library which also follows
  the similar philosophy of making functionality available to the user if they
  implement types which satisfy a certain set of requirements.
\end{abstract}

\section{Introduction}
Following from the motivation of \cite{GuyDavidson2019a},
\cite{GuyDavidson2019a} presents a design of linear algebra library that tries
For some years now, there have been efforts to add a linear algebra library in
the C++ standard library.

Standardization of library comes with varied requirements.
\begin{enumerate}
  \item The design is supposed to be general enough to handle almost all the use
    cases.
  \item The design is supposed
\end{enumerate}

Survey of past linear algebra libraries and the challenges and advantages of
various designs therein. (P1417R0)

Operators are important, why? Generic algorithm. Examples. How operators
differ.  Deciding which algorithm to use to implement operators. Why are
operators important?

Other challenges:
About expression templates refer to Klaus Igelberger paper. Move operations in
C++, and problems with expresion templates.



Additional challenges that the standard library imposes.
\begin{enumerate}
  \item Slow-moving
  \item backward compatibility
  \item Implementation challenges (PSTL)
  \item Some sort of future proofing
\end{enumerate}


common vocabulary types to allow different code bases to use each other without
having to make intermediate copies.


The problems arise when one tries to deal with operators. For example, how
should the expression \inlinecode{a+b}. Should we return a view? Or an
expression template? Or are we consuming a temporary and hence, should return by
value. How to deal with \inlinecode{a+b} where \inlinecode{a} and \inlinecode{b}
might belong to a different library. In current setups, there is no hope of
interoperability, because none/both of the libraries might implement
\inlinecode{a+b}. Both the situations are not ideal.
Is there a way to provide some interoperability? Optimal interoperability will
still require one to be careful, but can we provide a way to do it in a way that
is consistent with other good practices in C++?


Single type/library design. Dilemna of mixing library types.
\begin{enumerate}
  \item Comparison with `std::vector`, `boost::vector`,
    In most algorithms, one can use all the three without any functional
    difference.

  \item Why should linear algebra be different?

  \item At some point, people will need different types.

  \item Much more beneficial in our opinion to allow a design which accomodates
    different types rather than ask everyone to use a single type, however good
    that type is.

  \item Same goes for algorithms.

  \item This also lowers the expectation on the standard library to implement
    all types. This ensures that people can keep using standard library types
    and algorithms for their daily use without having to completely throw them
    away in cases where they wish to use something else.
\end{enumerate}

So, allow the user to be able to custom define operations like \inlinecode{a+b}
where a and b belong to different libraries.

This also lowers the expectation on the standard library design itself. Because
if the there is something which is not there in the standard library or if the
standard library for some reason or the another is not the fastest option, then
people can use other libraries without having to completely redesign their
code/introduce expensive copies.

\subsection{What this paper is not?}
This is not a proposal about including certain linear algebra types or functions
in the standard library. Rather, it is a paper which presents how the types and
functions can be designed to allow them to interact with one another. As a
result, the types used in this paper are minimal in order to highlight the
requirements that we wish to impose on the types.

\section{Some Traits}
\begin{codecpp}{Supporting Traits}
// Inherit from std::true_type if all the `Tp`s have a member typedef
// `engine_type` else inherit from std::false_type
template <class... Tp>
struct is_engine_aware {
};

// Inherit from std::true_type if all the `Tp`s have a member typedef
// `engine_type` and the type `engine_type` is convertible to `E` else inherit
// from std::false_type
template <typename E, typename... T>
struct uses_engine {
};


// Inherit from std::true_type if all the `Tp`s have a member typedef
// `is_owning_type` and the type `is_owning_type` is convertible to
// `std::true_type` else inherit from std::false_type
template <class Tp>
struct is_owning_type {
};

// Inherit from std::true_type if any one of the `T` satisfy both of the
// following properties:
// 1. std::is_owning_type_v<std::remove_cv_ref_t<T>> is true
// 2. std::is_rvalue_reference_v<T> is true
template <typename... T>
struct is_consuming_owning_type {
};
\end{codecpp}



\section{Engine-Aware Types}

\begin{codecpp}{An Engine-Aware Owning Type}
  template<typename E>
  class vector {
  public:
    using engine_type = E;
    using is_owning_type = std::true_type;

  public:
    template <typename NE>
    auto change_engine() && -> vector<NE>;

    template <typename NE>
    auto change_engine() & -> vector_view<NE, vector<E>>;

    template <typename NE>
    auto change_engine() const& -> vector_view<NE, vector<E> const>;
  };
\end{codecpp}

\begin{codecpp}{An Engine-Aware View/Expression Type}
  template<typename E>
  class vector_view {
  public:
    using engine_type = E;
    using is_owning_type = std::false_type;

  public:
    template <typename NE>
    auto change_engine() const -> vector_view<NE, owning_type>;
  };
\end{codecpp}

\section{Engine and Engine-Based Operators}

\begin{codecpp}{Engine and Engine-Based Operator}
struct serial_cpu_engine;

template <typename T, typename U>
struct addition_traits {
  using result_type = X ; // X can be determined using any logic required
};

template <typename T, typename U>
struct addition_engine {
  auto operator()(T&& t, U&& u) -> addition_traits_r<T, U>
  {
    auto const size = t.size();
    auto result = addition_traits_r<T, U>(size);
    for (std::size_t i = 0; i < size; ++i) {
      result(i) = t(i) + u(i);
    }
  }
};

template <typename T,
          typename U,
          typename = std::enable_if<
            std::experimental::math::uses_engine_v<serial_cpu_engine, T, U>>>
auto operator+(T&& t, U&& u) -> addition_traits_r<T&&, U&&>
{
  auto constexpr ae = addition_engine<T, U>();
  return ae(std::forward<T>(t), std::forward<U>(u));
}

template <typename T,
          typename U,
          typename = std::enable_if<
            std::experimental::math::uses_engine_v<serial_cpu_engine, T, U>>>
auto operator+(T&& t, U&& u) -> addition_traits_r<T&&, U&&>
{
  return t.change_engine<some_other>() + u.change_engine<some_other>();
}

\end{codecpp}
\section{Some Musings on Design Decisions}
\subsection{Use of ADL in Detection of Correct Operator Namespace}
Justification and Pitfalls (Could also be thought of as good design decisions.)

Good practice is not to write operators for linear algebra types but instead
write them for the engines.
\subsection{More Fine Tuned Traits}
Arbitrarily more finely tuned traits can be taken care of the
\inlinecode{addition\_traits}.  But we should be careful as to prevent trait
explosion.
\begin{enumerate}
  \item  `Sparsity`  trait definitely needed
  \item  `Host/Device` trait should be useful
  \item  Access Pattern Traits
\end{enumerate}
\section{Example}

\begin{codecpp}{Example of How the Code Might Look}

  using sce = std::math::serial_cpu_engine;
  using pce =custom_lib::parallel_cpu_engine;
  using stdvec = std::math::vector;
  using custvec = another_lib::vector;

  auto const ov1 = stdvec<sce>(arg...);
  auto const ov2 = custvec<sce>(arg...);

  auto const view_3 = ov1 + ov2;

  auto const view_4 = ov1.change_engine<pce>();
  auto const ov5 = (custvec<sce>(args...)).change_engine<pce>();

  auto const view_6 = view_4 + ov5;

  auto const ov7 = stdvec<pce>(args...) + ov1;

\end{codecpp}
\section{Acknowledgement}
A lot of ideas have been gathered by participating in the SG14 Linear Algebra
SIG discussions, reading the codebases like Eigen, MTL, Blaze and others etc.
While I have tried to credit the ideas wherever necessary, if you find your
ideas being used in the code without credit, I apologize in advance. Also, I
would be grateful if you could bring them to my attention so that I could write
them as such.

The idea of offloading the computations to an engine is inspired from
\cite{GuyDavidson2019}. The idea to use execution policy is inspired from MTL
\incomplete{Check this?}.


\printbibliography
\end{document}
