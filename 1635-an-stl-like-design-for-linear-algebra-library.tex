\documentclass[oneside,11pt,a4paper]{jbarticle}

\addbibresource{library.bib}

\subject{}
\subtitle{}
\title{D1635R0 : A Design for an Inter-Operable and Customizable Linear Algebra Library}
\author{Jayesh Badwaik}

\begin{document}
\maketitle[\value{page}]
\begin{abstract}
  A linear algebra library is currently being considered for standardization in
  the C++ standard library through \cite{GuyDavidson2019}.
  In this paper, we show how a well-designed set of requirements imposed on the
  types and the functions allow the users to write their linear algebra library
  that allows interoperability between libraries while preserving the objectives
  laid out for the library.
\end{abstract}

\section{Introduction}

In the past few years, there has been an effort to a linear algebra library to
the standard library. The motivations for the effort can be found in
\cite{GuyDavidson2019a}. There are already quite a few papers in flight
concerning the design, with the primary one being \cite{GuyDavidson2019}. The
papers are mostly concerned with the design of standard library itself and as
such, do not deal with interaction of the standard library with user-implemented
linear algebra libraries.  This means that some aspects of the design are not
covered in the papers. We illustrate some of the aspects in

This paper is in that sense a little more abstract. Instead of laying out a
collection of types and functions for the linear algebra, we layout a set of
requirements for the types of user-written library to satisfy in order to allow
for the libraries to be interoperable with the standard library and with each
other. We illustrate a selection of the problems that motivated this paper


Consider the following code
\begin{codecpp}{Multiplication Operator Between A Vector and a Matrix from
  Different Libraries}
  auto const x = a::f();  // Returns vector x of type a::vector
  auto const A = b::g();  // Returns a matrix b of type b::matrix
  auto const b = A * x;   // ERROR: operator* not defined!!
\end{codecpp}
In general, there will not be an \inlinecode{operator*} defined for the types
\inlinecode{a::vector} and \inlinecode{b::matrix}. In fact, there is no good way
to define an \inlinecode{operator*} in this case without invading on one of the
two namespaces.  One of the solutions to these problems is to specify some
vocabulary types and then expect all users to use the given vocabulary types.
But this approach imposes a restriction on the types that can be designed for
use with the linear algebra library, and make including new paradigms difficult
to achieve.

Consider another example as shown below:
\begin{codecpp}{Multiplication Operator Between A Vector and a Matrix}
  auto const x = a::f();  // Returns vector x of type a::vector
  auto const A = a::g();  // Returns a matrix b of type a::matrix
  auto const b = A * x;   // Assume that operator* is serial (not parallel)
\end{codecpp}
Assume that the \inlinecode{operator*} is serial in this case. But suppose that
the user wants to allow the computation to be parallel (or probably offloaded to
the GPU) in only some places in the code while requiring the computation to run
in serial in other places. There can be quite a few scenarios where such a
behavior is desirable. For example, it is possible that the operator which is
expected to run in serial is already a part of a parallelly-executed code
segment.

Apart from these problems, there are other issues which need to be
tackled

Talk about objective, talk about how the objectives show themselves in terms of
customization, operator algebra and other things. Discuss Blaze library
multiplication. Discuss difficulties of move operations with a+b. and so on.
Operators are important, why? Generic algorithm. Examples. How operators
differ.  Deciding which algorithm to use to implement operators. Why are
operators important? Discuss expression templates.
About expression templates refer to Klaus Igelberger paper. Move operations in
C++, and problems with expresion templates. Finally, discuss the situation about
different library types.

common vocabulary types to allow different code bases to use each other without
having to make intermediate copies.


The problems arise when one tries to deal with operators. For example, how
should the expression \inlinecode{a+b}. Should we return a view? Or an
expression template? Or are we consuming a temporary and hence, should return by
value. How to deal with \inlinecode{a+b} where \inlinecode{a} and \inlinecode{b}
might belong to a different library. In current setups, there is no hope of
interoperability, because none/both of the libraries might implement
\inlinecode{a+b}. Both the situations are not ideal.
Is there a way to provide some interoperability? Optimal interoperability will
still require one to be careful, but can we provide a way to do it in a way that
is consistent with other good practices in C++?


Single type/library design. Dilemna of mixing library types.
\begin{enumerate}
  \item Comparison with `std::vector`, `boost::vector`,
    In most algorithms, one can use all the three without any functional
    difference.

  \item Why should linear algebra be different?

  \item At some point, people will need different types.

  \item Much more beneficial in our opinion to allow a design which accomodates
    different types rather than ask everyone to use a single type, however good
    that type is.

  \item Same goes for algorithms.

  \item This also lowers the expectation on the standard library to implement
    all types. This ensures that people can keep using standard library types
    and algorithms for their daily use without having to completely throw them
    away in cases where they wish to use something else.
\end{enumerate}

So, allow the user to be able to custom define operations like \inlinecode{a+b}
where a and b belong to different libraries.

This also lowers the expectation on the standard library design itself. Because
if the there is something which is not there in the standard library or if the
standard library for some reason or the another is not the fastest option, then
people can use other libraries without having to completely redesign their
code/introduce expensive copies.

\subsection{Some Comments about the Paper}
This is not a proposal about including certain linear algebra types or functions
in the standard library. Rather, it is a paper which presents how the types and
functions can be designed to allow types from different library to interact
with one another. Therefore the types presented in this paper are minimal in
that, only the features required to highlight the functionality are implemented.

We are aware that a lot of language in the paper can be rewritten in the
form of Concepts but we are not comfortable with the language and decided to use
a traits based exposition in order to make sure that we do not introduce
additional errors in the papers.

\subsection{A Comment about the Code}

\section{Some Traits}
We start with introducing some trait types which will be useful for the
discussion later.

\begin{codecpp}{Engine-Aware Trait}
// Inherit from std::true_type if all the `Tp`s have a member typedef
// `engine_type` else inherit from std::false_type
template <typename... Tp>
struct is_engine_aware;
\end{codecpp}

\begin{codecpp}{Uses-Engine Trait}
// Inherit from std::true_type if all the `Tp`s have a member typedef
// `engine_type` and the type `engine_type` is convertible to `E` else inherit
// from std::false_type
template <typename E, typename... Tp>
struct uses_engine ;
\end{codecpp}



\begin{codecpp}{Supporting Traits}


// Inherit from std::true_type if all the `Tp`s have a member typedef
// `is_owning_type` and the type `is_owning_type` is convertible to
// `std::true_type` else inherit from std::false_type
template <typename... Tp>
struct is_owning_type ;

// Inherit from std::true_type if any one of the `T` satisfy both of the
// following properties:
// 1. std::is_owning_type_v<std::remove_cv_ref_t<T>> is true
// 2. std::is_rvalue_reference_v<T> is true
template <typename... Tp>
struct is_consuming_owning_type;
\end{codecpp}



\section{Engine-Aware Types}
The dilemna for defining `a+b` without copy comes from the fact that if one
follows the good practices of not declaring operator for in the namespace of
someone else, neither `a` nor `b` nor the user `c` can define the
`operator+(a,b)`. We resolve this difficulty as follows:



\begin{codecpp}{An Engine-Aware Owning Type}
  template<typename E>
  class vector {
  public:
    using engine_type = E;
    using is_owning_type = std::true_type;

  public:
    template <typename NE>
    auto change_engine() && -> vector<NE>;

    template <typename NE>
    auto change_engine() & -> vector_view<NE, vector<E>>;

    template <typename NE>
    auto change_engine() const& -> vector_view<NE, vector<E> const>;
  };
\end{codecpp}

\begin{codecpp}{An Engine-Aware View/Expression Type}
  template<typename E>
  class vector_view {
  public:
    using engine_type = E;
    using is_owning_type = std::false_type;

  public:
    template <typename NE>
    auto change_engine() const -> vector_view<NE, owning_type>;
  };
\end{codecpp}

\section{Engine and Engine-Based Operators}

\begin{codecpp}{Engine and Engine-Based Operator}
struct serial_cpu_engine;

template <typename T, typename U>
struct addition_traits {
  using result_type = X ; // X can be determined using any logic required
};

template <typename T, typename U>
struct addition_engine {
  auto operator()(T&& t, U&& u) -> addition_traits_r<T, U>
  {
    auto const size = t.size();
    auto result = addition_traits_r<T, U>(size);
    for (std::size_t i = 0; i < size; ++i) {
      result(i) = t(i) + u(i);
    }
  }
};

template <typename T,
          typename U,
          typename = std::enable_if<
            std::experimental::math::uses_engine_v<serial_cpu_engine, T, U>>>
auto operator+(T&& t, U&& u) -> addition_traits_r<T&&, U&&>
{
  auto constexpr ae = addition_engine<T, U>();
  return ae(std::forward<T>(t), std::forward<U>(u));
}

template <typename T,
          typename U,
          typename = std::enable_if<
            std::experimental::math::uses_engine_v<serial_cpu_engine, T, U>>>
auto operator+(T&& t, U&& u) -> addition_traits_r<T&&, U&&>
{
  return t.change_engine<some_other>() + u.change_engine<some_other>();
}

\end{codecpp}
\section{Some Musings on Design Decisions}
Compile Times due to SFINAE
IsVector trait
\subsection{Use of ADL in Detection of Correct Operator Namespace}
Justification and Pitfalls (Could also be thought of as good design decisions.)

Good practice is not to write operators for linear algebra types but instead
write them for the engines.
\subsection{More Fine Tuned Traits}
Arbitrarily more finely tuned traits can be taken care of the
\inlinecode{addition\_traits}.  But we should be careful as to prevent trait
explosion.
\begin{enumerate}
  \item  `Sparsity`  trait definitely needed
  \item  `Host/Device` trait should be useful
  \item  Access Pattern Traits
\end{enumerate}
\section{Example}

\begin{codecpp}{Example of How the Code Might Look}

  using sce = std::math::serial_cpu_engine;
  using pce =custom_lib::parallel_cpu_engine;
  using stdvec = std::math::vector;
  using custvec = another_lib::vector;

  auto const ov1 = stdvec<sce>(arg...);
  auto const ov2 = custvec<sce>(arg...);

  auto const view_3 = ov1 + ov2;

  auto const view_4 = ov1.change_engine<pce>();
  auto const ov5 = (custvec<sce>(args...)).change_engine<pce>();

  auto const view_6 = view_4 + ov5;

  auto const ov7 = stdvec<pce>(args...) + ov1;

\end{codecpp}
\section{Acknowledgement}
A lot of ideas have been gathered by participating in the SG14 Linear Algebra
SIG discussions, reading the codebases like Eigen, MTL, Blaze and others etc.

\printbibliography
\end{document}
