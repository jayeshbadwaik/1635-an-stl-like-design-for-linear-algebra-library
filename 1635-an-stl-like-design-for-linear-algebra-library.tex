\documentclass[oneside,11pt,a4paper]{jbarticle}

\addbibresource{library.bib}

\subject{}
\subtitle{}
\title{D1635R0 : An STL-like Design for Linear Algebra Library}
\author{Jayesh Badwaik}

\begin{document}
\maketitle[\value{page}]
\begin{abstract}
  A linear algebra library is currently being considered for standardization in
  the C++ standard library through \cite{GuyDavidson2019}. Among other things,
  the above paper puts forth the objective of providing facilities and
  techniques for customization that enable users to optimize performance for
  their specific needs in a manner that only requires them to implement a
  minimal set of types and functions to integrate it with the rest of the linear
  algebra libraries.

  In this paper, we how a well-designed set of requirements imposed on
  the types and the functions allow us to write a linear algebra library which
  fulfills the above two objectives.  We also show how the design allows one
  to carry out operation between types of libraries designed as above without
  having to perform generate additional temporaries for the purpose of
  compatibility of the two libraries.
\end{abstract}

\section{Introduction}
Consider the following code
\begin{codecpp}{Multiplication Operator Between A Vector and a Matrix}
  auto const x = a::f(); // Returns vector x of type a::vector
  auto const A = b::g(); // Returns a matrix b of type b::matrix
  auto const b = A * x;
\end{codecpp}

In most of the code today, one cannot compile this code and instead one has to
first convert either \inlinecode{a} to a type which is understandable by library
\inlinecode{b}.

Talk about objective, talk about how the objectives show themselves in terms of
customization, operator algebra and other things. Discuss Blaze library
multiplication. Discuss difficulties of move operations with a+b. and so on.
Operators are important, why? Generic algorithm. Examples. How operators
differ.  Deciding which algorithm to use to implement operators. Why are
operators important? Discuss expression templates.
About expression templates refer to Klaus Igelberger paper. Move operations in
C++, and problems with expresion templates. Finally, discuss the situation about
different library types.

common vocabulary types to allow different code bases to use each other without
having to make intermediate copies.


The problems arise when one tries to deal with operators. For example, how
should the expression \inlinecode{a+b}. Should we return a view? Or an
expression template? Or are we consuming a temporary and hence, should return by
value. How to deal with \inlinecode{a+b} where \inlinecode{a} and \inlinecode{b}
might belong to a different library. In current setups, there is no hope of
interoperability, because none/both of the libraries might implement
\inlinecode{a+b}. Both the situations are not ideal.
Is there a way to provide some interoperability? Optimal interoperability will
still require one to be careful, but can we provide a way to do it in a way that
is consistent with other good practices in C++?


Single type/library design. Dilemna of mixing library types.
\begin{enumerate}
  \item Comparison with `std::vector`, `boost::vector`,
    In most algorithms, one can use all the three without any functional
    difference.

  \item Why should linear algebra be different?

  \item At some point, people will need different types.

  \item Much more beneficial in our opinion to allow a design which accomodates
    different types rather than ask everyone to use a single type, however good
    that type is.

  \item Same goes for algorithms.

  \item This also lowers the expectation on the standard library to implement
    all types. This ensures that people can keep using standard library types
    and algorithms for their daily use without having to completely throw them
    away in cases where they wish to use something else.
\end{enumerate}

So, allow the user to be able to custom define operations like \inlinecode{a+b}
where a and b belong to different libraries.

This also lowers the expectation on the standard library design itself. Because
if the there is something which is not there in the standard library or if the
standard library for some reason or the another is not the fastest option, then
people can use other libraries without having to completely redesign their
code/introduce expensive copies.

\subsection{Some Comments about the Paper}
This is not a proposal about including certain linear algebra types or functions
in the standard library. Rather, it is a paper which presents how the types and
functions can be designed to allow types from different library to interact
with one another. Therefore the types presented in this paper are minimal in
that, only the features required to highlight the functionality are implemented.

We are aware that a lot of language in the paper can be rewritten in the
form of Concepts but we are not comfortable with the language and decided to use
a traits based exposition in order to make sure that we do not introduce
additional errors in the papers.

\subsection{A Comment about the Code}

\section{Some Traits}
We start with introducing some trait types which will be useful for the
discussion

isvector trait
ismatrix trait

\begin{codecpp}{Supporting Traits}
// Inherit from std::true_type if all the `Tp`s have a member typedef
// `engine_type` else inherit from std::false_type
template <class... Tp>
struct is_engine_aware {
};

// Inherit from std::true_type if all the `Tp`s have a member typedef
// `engine_type` and the type `engine_type` is convertible to `E` else inherit
// from std::false_type
template <typename E, typename... T>
struct uses_engine {
};


// Inherit from std::true_type if all the `Tp`s have a member typedef
// `is_owning_type` and the type `is_owning_type` is convertible to
// `std::true_type` else inherit from std::false_type
template <class Tp>
struct is_owning_type {
};

// Inherit from std::true_type if any one of the `T` satisfy both of the
// following properties:
// 1. std::is_owning_type_v<std::remove_cv_ref_t<T>> is true
// 2. std::is_rvalue_reference_v<T> is true
template <typename... T>
struct is_consuming_owning_type {
};
\end{codecpp}



\section{Engine-Aware Types}
The dilemna for defining `a+b` without copy comes from the fact that if one
follows the good practices of not declaring operator for in the namespace of
someone else, neither `a` nor `b` nor the user `c` can define the
`operator+(a,b)`. We resolve this difficulty as follows:



\begin{codecpp}{An Engine-Aware Owning Type}
  template<typename E>
  class vector {
  public:
    using engine_type = E;
    using is_owning_type = std::true_type;

  public:
    template <typename NE>
    auto change_engine() && -> vector<NE>;

    template <typename NE>
    auto change_engine() & -> vector_view<NE, vector<E>>;

    template <typename NE>
    auto change_engine() const& -> vector_view<NE, vector<E> const>;
  };
\end{codecpp}

\begin{codecpp}{An Engine-Aware View/Expression Type}
  template<typename E>
  class vector_view {
  public:
    using engine_type = E;
    using is_owning_type = std::false_type;

  public:
    template <typename NE>
    auto change_engine() const -> vector_view<NE, owning_type>;
  };
\end{codecpp}

\section{Engine and Engine-Based Operators}

\begin{codecpp}{Engine and Engine-Based Operator}
struct serial_cpu_engine;

template <typename T, typename U>
struct addition_traits {
  using result_type = X ; // X can be determined using any logic required
};

template <typename T, typename U>
struct addition_engine {
  auto operator()(T&& t, U&& u) -> addition_traits_r<T, U>
  {
    auto const size = t.size();
    auto result = addition_traits_r<T, U>(size);
    for (std::size_t i = 0; i < size; ++i) {
      result(i) = t(i) + u(i);
    }
  }
};

template <typename T,
          typename U,
          typename = std::enable_if<
            std::experimental::math::uses_engine_v<serial_cpu_engine, T, U>>>
auto operator+(T&& t, U&& u) -> addition_traits_r<T&&, U&&>
{
  auto constexpr ae = addition_engine<T, U>();
  return ae(std::forward<T>(t), std::forward<U>(u));
}

template <typename T,
          typename U,
          typename = std::enable_if<
            std::experimental::math::uses_engine_v<serial_cpu_engine, T, U>>>
auto operator+(T&& t, U&& u) -> addition_traits_r<T&&, U&&>
{
  return t.change_engine<some_other>() + u.change_engine<some_other>();
}

\end{codecpp}
\section{Some Musings on Design Decisions}
Compile Times due to SFINAE
IsVector trait
\subsection{Use of ADL in Detection of Correct Operator Namespace}
Justification and Pitfalls (Could also be thought of as good design decisions.)

Good practice is not to write operators for linear algebra types but instead
write them for the engines.
\subsection{More Fine Tuned Traits}
Arbitrarily more finely tuned traits can be taken care of the
\inlinecode{addition\_traits}.  But we should be careful as to prevent trait
explosion.
\begin{enumerate}
  \item  `Sparsity`  trait definitely needed
  \item  `Host/Device` trait should be useful
  \item  Access Pattern Traits
\end{enumerate}
\section{Example}

\begin{codecpp}{Example of How the Code Might Look}

  using sce = std::math::serial_cpu_engine;
  using pce =custom_lib::parallel_cpu_engine;
  using stdvec = std::math::vector;
  using custvec = another_lib::vector;

  auto const ov1 = stdvec<sce>(arg...);
  auto const ov2 = custvec<sce>(arg...);

  auto const view_3 = ov1 + ov2;

  auto const view_4 = ov1.change_engine<pce>();
  auto const ov5 = (custvec<sce>(args...)).change_engine<pce>();

  auto const view_6 = view_4 + ov5;

  auto const ov7 = stdvec<pce>(args...) + ov1;

\end{codecpp}
\section{Acknowledgement}
A lot of ideas have been gathered by participating in the SG14 Linear Algebra
SIG discussions, reading the codebases like Eigen, MTL, Blaze and others etc.

\printbibliography
\end{document}
